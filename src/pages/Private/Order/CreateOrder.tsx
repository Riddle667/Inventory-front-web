import {
  Box,
  Typography,
  CircularProgress,
  Alert,
  IconButton,
  TextField,
  MenuItem,
  Button,
  Checkbox,
  Autocomplete,
} from "@mui/material";
import { ArrowBack } from "@mui/icons-material";
import { useEffect, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { themes, useThemeContext } from "@/context";
import {
  Installment,
  Order,
  OrderProduct,
  PrivateRoutes,
  Product,
} from "@/models";
import { CreateOrderUseCase, ViewProductsUseCase } from "@/useCase";
import { AxiosError } from "axios";
import { ResponseAPI } from "@/utilities";
import { useDispatch, useSelector } from "react-redux";
import { AppStore } from "@/redux/store";
import { resetUser } from "@/redux";

export const CreateOrder: React.FC = () => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [searchValue, setSearchValue] = useState<string>("");
  const [selectedQuantity, setSelectedQuantity] = useState<number>(1);
  const [installmentsQuantity, setInstallmentsQuantity] = useState<number>(1);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);

  const { theme } = useThemeContext();
  const navigate = useNavigate();
  const user = useSelector((store: AppStore) => store.user);
  const token = user?.session_token ?? "";
  const dispatch = useDispatch();
  const { id } = useParams();

  const [orderData, setOrderData] = useState<Order>({
    id: 0,
    total_price: 0,
    paid: false,
    pay_method: "",
    is_installment: false,
    client_id: Number(id),
    products: [],
    installments: [],
  });

  useEffect(() => {
    fetchProducts();
  }, []);

  const fetchProducts = async () => {
    try {
      const { data } = await ViewProductsUseCase(token);
      if (Array.isArray(data)) {
        setProducts(data as Product[]);
      } else {
        console.warn("Los datos obtenidos no son un arreglo:", data);
        setProducts([]);
      }
    } catch (error) {
      const e = error as AxiosError & ResponseAPI;
      if (e.message === "No token provided" || e.message === "token expired") {
        dispatch(resetUser());
        navigate("/", { replace: true });
      }
    }
  };

  const handleAddProduct = (productId: number) => {
    const product = products.find((p) => p.id === productId);
    if (!product) return;

    const newProduct: OrderProduct = {
      id: 0, // This ID will be generated by the backend
      product_id: productId,
      quantity: selectedQuantity,
      total_price: product.price * selectedQuantity,
    };

    setOrderData((prev) => ({
      ...prev,
      products: [...prev.products, newProduct],
      total_price: prev.total_price + newProduct.total_price,
    }));

    setSelectedProduct(null);
    setSelectedQuantity(1);
  };

  const handleRemoveProduct = (index: number) => {
    const productToRemove = orderData.products[index];
    setOrderData((prev) => ({
      ...prev,
      products: prev.products.filter((_, i) => i !== index),
      total_price: prev.total_price - productToRemove.total_price,
    }));
  };

  const handleSubmit = async () => {
    try {
      setLoading(true);
      setError(null);

      // Verificar si los datos básicos están completos
      if (
        !orderData.client_id ||
        !orderData.total_price ||
        !orderData.products.length
      ) {
        throw new Error("Faltan datos necesarios para crear la orden.");
      }

      // Generar cuotas si la orden es a plazos
      let installments: Installment[] = [];
      if (orderData.is_installment) {
        const currentDate = new Date();
        const installmentAmount = orderData.total_price / installmentsQuantity;

        installments = Array.from({ length: installmentsQuantity }, (_, i) => ({
          id: 0, // Este ID será generado por el backend
          order_id: 0, // Será asignado al crearse la orden
          installment_number: i + 1,
          amount: parseFloat(installmentAmount.toFixed(2)), // Asegurar precisión decimal
          due_date: new Date(
            currentDate.getFullYear(),
            currentDate.getMonth() + i + 1,
            currentDate.getDate()
          ),
          paid: false,
        }));

        // Validar que la suma de las cuotas coincida con el precio total
        const totalInstallments = installments.reduce(
          (sum, inst) => sum + inst.amount,
          0
        );
        if (Math.abs(totalInstallments - orderData.total_price) > 0.01) {
          throw new Error(
            "La suma de las cuotas no coincide con el precio total."
          );
        }
      }

      // Actualizar el estado con las cuotas generadas
      const preparedOrderData = {
        ...orderData,
        installments,
      };

      // Enviar datos al backend
      const data = (await CreateOrderUseCase(
        token,
        preparedOrderData
      )) as ResponseAPI;
      console.log("Respuesta del backend:", data);

      if (data) {
        navigate(
          `/${PrivateRoutes.PRIVATE}/${PrivateRoutes.DETAILS_CLIENTS}/${id}`
        );
      } else {
        throw new Error("No se pudo crear la orden.");
      }
    } catch (error) {
      // Manejo de errores
      const e = error as AxiosError & ResponseAPI;
      if (e.message === "No token provided" || e.message === "token expired") {
        dispatch(resetUser());
        navigate("/", { replace: true });
        return "Sesión expirada. Por favor, inicie sesión nuevamente.";
      }

      setError(e.message || "Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box
      sx={{
        backgroundColor: themes[theme].sidebar.backgroundColor,
        color: themes[theme].text.paragraph,
        padding: "2rem",
        borderRadius: "8px",
        width: "90%",
        boxShadow: "0px 4px 12px rgba(0, 0, 0, 0.1)",
        marginTop: "2rem",
      }}
    >
      <Box sx={{ position: "relative", marginBottom: "1rem" }}>
        <IconButton
          onClick={() =>
            navigate(
              `/${PrivateRoutes.PRIVATE}/${PrivateRoutes.DETAILS_CLIENTS}/${id}`
            )
          }
        >
          <ArrowBack sx={{ color: themes[theme].menu.icon }} />
        </IconButton>
        <Typography
          variant="h4"
          sx={{ textAlign: "center", color: themes[theme].text.title }}
        >
          Crear Nueva Orden
        </Typography>
      </Box>

      {loading && (
        <Box sx={{ textAlign: "center" }}>
          <CircularProgress />
          <Typography>Creando orden...</Typography>
        </Box>
      )}

      {error && <Alert severity="error">{error}</Alert>}

      {!loading && (
        <Box sx={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
          <Typography variant="h6">Productos Seleccionados:</Typography>

          {orderData.products.map((item, index) => (
            <Box
              key={index}
              sx={{
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
              }}
            >
              <Typography>
                {products.find((p) => p.id === item.product_id)?.name} -{" "}
                {item.quantity} unidades
              </Typography>
              <Button color="error" onClick={() => handleRemoveProduct(index)}>
                Eliminar
              </Button>
            </Box>
          ))}

          <Typography>Total: ${orderData.total_price.toFixed(2)}</Typography>

          <Box sx={{ display: "flex", gap: "1rem", alignItems: "center" }}>
            <Autocomplete
              options={products}
              getOptionLabel={(option) => option.name || ""}
              value={
                products.find((product) => product.name === searchValue) || null
              }
              onInputChange={(e, newValue) => setSearchValue(newValue)}
              renderInput={(params) => (
                <TextField {...params} label="Buscar Producto" />
              )}
              onChange={(e, product) => product && setSelectedProduct(product)}
              sx={{ flex: 2 }}
            />

            <TextField
              label="Cantidad"
              type="number"
              value={selectedQuantity}
              onChange={(e) => setSelectedQuantity(Number(e.target.value))}
              fullWidth
              sx={{ flex: 1 }}
            />

            <Typography variant="body2" color="textSecondary">
              Stock:{" "}
              {selectedProduct
                ? products.find((p) => p.id === selectedProduct.id)?.stock
                : "-"}
            </Typography>

            <Button
              variant="contained"
              onClick={() =>
                selectedProduct && handleAddProduct(selectedProduct.id)
              }
              disabled={
                !selectedProduct ||
                selectedQuantity <= 0 ||
                selectedQuantity >
                  (products.find((p) => p.id === selectedProduct?.id)?.stock ??
                    0)
              }
              sx={{ flex: 1 }}
            >
              Agregar
            </Button>
          </Box>

          <TextField
            label="Método de Pago"
            select
            name="pay_method"
            value={orderData.pay_method}
            onChange={(e) =>
              setOrderData({ ...orderData, pay_method: e.target.value })
            }
            fullWidth
          >
            <MenuItem value="cash">Efectivo</MenuItem>
            <MenuItem value="card">Tarjeta</MenuItem>
            <MenuItem value="transfer">Transferencia</MenuItem>
          </TextField>

          <Box sx={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
            <Typography>¿Con Cuotas?</Typography>
            <Checkbox
              checked={orderData.is_installment}
              onChange={(e) =>
                setOrderData({
                  ...orderData,
                  is_installment: e.target.checked,
                })
              }
            />
          </Box>

          {orderData.is_installment && (
            <TextField
              label="Cantidad de Cuotas"
              type="number"
              value={installmentsQuantity}
              onChange={(e) => setInstallmentsQuantity(Number(e.target.value))}
              fullWidth
            />
          )}

          <Button variant="contained" onClick={handleSubmit}>
            Crear Orden
          </Button>
        </Box>
      )}
    </Box>
  );
};
